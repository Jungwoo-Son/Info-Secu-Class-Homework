# 자료구조, 알고리즘

### 큐

FIFO

Enqueue 데이터 입력

Dequeue 데이터 삭제

사용처 : job 큐, BFS



### 스택

LIFO

Push 데이터 입력

Pop 데이터 삭제

스택 오버 플로우 : 스택이 이미 찼을 때 다시 push하는 경우 일어나는 에러

스택 언더 플로우 : 스택이 비어있을 때 Pop하면 일어하는 에러

사용처 : 뒤로가기, DFS



### 링크드리스트

Node : 값을 가지고 다음 Node를 가리킨다

추가 : 앞 원소가 될 node의 next로 지정한다

출력 : 앞에서 부터 순회하며 출력한다

삭제 : 삭제할 노드 전 노드의 next를 삭제할 노드의 다음 노드로 지정, 삭제할 노드를 삭제한다



### 힙

최대 힙 트리 : 부모는 자식보다 크다

최소 힙 트리 : 부모는 자식보다 작다



siftdown : 바로 아래 자식노드와 비교에 가장 큰 값(가장 작은 값)을 부모로 두는 연산



힙트리 만들기 : 자식이 있는 마지막 노드에서부터 siftdown을 재귀적으로 진행하며 루트 노드까지 올라간다



### 힙 정렬 알고리즘

1. 힙트리 만들기
2. 루트 값 저장
3. 가장 마지막 노드와 루트 스왑
4. 힙 트리 사이즈 1 줄이기
5. 루트 노드 siftdown 진행(자식과 바꾸면 바꾸면 그 자리에서 다시 siftdown)
6. 힙 트리 사이즈가 0이 될때 까지 2번 부터 5번 반복



### 이진탐색트리 알고리즘

현재 노드보다 작은 값은 왼쪽, 큰 값은 오른쪽

추가 : 추가할 값 보다 현재 노드가 큰 경우 왼쪽, 아닌 경우 오른쪽으로 가고 이를 재귀적 반복 현재 노드가 없으면 거기에 추가

탐색 : 탐색할 값 보다 현재 노드가 큰 경우 왼쪽, 아닌 경우 오른쪽으로 가고 이를 탐색 성공시 까지 재귀적 반복 노드가 없으면 탐색 실패

삭제 : 자식이 없으면 그냥 삭제, 자식이 하나면 그 자식이 현재의 자리를 대체, 자식이 둘이면 한 쪽 자식으로 가고 자식의 방향과 반대 방향의 자식의 자식으로 계속 이동. 이 과정 중 자식이 없으면 그 노드가 현재의 자리를 대체



전위 순회 : 루트, 왼쪽, 오른쪽   <- 트리 재형성 가능

중위 순회 : 왼쪽, 루트, 오른쪽   <- 오름차순 정렬

후위 순회 : 오른쪽, 왼쪽, 루트  



### 그래프

정점, 간선을 가진다

무방향 그래프 : 간선에 방향이 없음

가중치 그래프 : 간선에 가중치가 존재

정점 리스트 : 모든 정점의 정보가 담긴 리스트

간선 리스트 : 모든 간선의 정보가 담긴 리스트

인접(adjacency) 리스트 : 각 정점이 간선을 통해 연결한 정점을 모은 것들의 리스트

인접 행렬 : 가로축, 세로축 모두 정점인 행렬에서 서로 연결 된 정보를 가진 곳에 표시 



### 깊이우선탐색

1. 현재 노드와 연결된 정점을 모두 스택에 넣기 (단 정점이 이미 지났다는 표시가 있을 경우 무시)
2. 현재 노드를 지났음을 표시
3. 스택에서 pop한 후 이를 현재 노드로 설정
4. 1번에서 3번 반복

만약 이런 과정에서도 지난 노드를 다시 지나게 된다면 이는 그래프에 사이클이 존재함을 의미함
(사이클이 있다면 사이클 중 하나 이상의 정점이 스택에 들어갔지만 당장 처리 되지않고 있어 지남 표시가 되기전에 다시 스택에 들어오게 된다)



### 너비우선탐색

1. 현재 노드와 연결된 정점 모두 큐에 넣기 (단 정점이 이미 지났다는 표시가 있을 경우 무시)
2. 현재 노드를 지났음을 표시
3. 큐에서 Dequeue한 후 이를 현재 노드로 설정
4. 1번에서 3번 반복



### 다익스트라 알고리즘(최단 경로 알고리즘)

1. 시작 정점를 정한다
2. 그 정점에서 다른 모든 정점으로 단번에 가는 길이를 기록한다 (불가능하다면 무한대 표시)
3. 현재 노드를 지나갔음을 표시한다
4. 현재 기록이 가장 작은 정점을 선택한다 (선택시 지나간 노드는 제외)
5. 현재 정점의 기록에서 현재 정점에서 다른 모든 정점으로 단번에 가는 길이를 더한다 (불가능하다면 무한대 표시)
6. 더한 값이 기록보다 작다면 기록을 더한 값으로 갱신한다
7. 모든 정점을 지날 때까지 3~6번 반복

이러고 나면 기록들은 시작 정점에서 최단 길이를 알려준다
갱신할 때마다 현재 노드를 기록했다면 그 기록을 거꾸로(스택 이용) 따라가서 경로를 알 수 있다



### 순열 알고리즘

주어진 리스트에서 순서를 바꿀 시 만들어지는 모든 경우

1. n은 요소의 갯수이며, m은 현재 1이다
2. m 번째 요소를 모든 요소와 스왑한다
3. m = m + 1
4. 그 각각의 결과들에서 m 번째 요소를 m번째 이상의 모든 요소들과 스왑한다
5. 기존의 결과를 저장 또는 출력 등을 한 후 연산에서 배제한다 
6. 3~5번을 총 n -1 번 반복한다

위의 과정을 거치고 난 후의 모든 결과들은 주어진 리스트에서 순서를 바꿔 만들 수 있는 모든 경우이다



### 비트 연산자

| --              | 두 개의 인자가 1일 때 1                |
| --------------- | -------------------------------------- |
| or(\|)          | 두 개의 인자 중 하나라도 1일 때 1      |
| xor(^)          | 두 개의 인자가 다를  시 1              |
| not(~)          | 0은 1로 1은 0으로                      |
| left shift(<<)  | 좌항의 비트를 우항만큼 왼쪽으로 밀음   |
| right shift(>>) | 좌항의 비트를 우항만큼 오른쪽으로 밀음 |















